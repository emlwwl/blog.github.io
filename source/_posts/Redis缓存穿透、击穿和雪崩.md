---
title: Redis穿透、击穿和雪崩
date: 2021-03-23 17:05:55
tags: Redis
categories: 
- Redis
---

## 一、缓存穿透

**缓存穿透是什么？**

如果每次都去查一个“缓存和数据库中都必不存在的数据（如id=-1的数据）”，因为缓存中不存在，那么每次请求都会打到DB上，从而导致缓存失去意义，在**高并发**的情况下就可能导致数据库崩溃，这就是缓存穿透。 

**缓存穿透的解决方案**

<!--more-->

1、缓存空值

简单粗暴，如果查询DB返回的数据为空，我们仍然把这个空值放到Redis缓存中，只是将它的过期时间设置的很短，另外为了避免不必要的内存消耗，可以定期清理空值的key。 

2、限流

常见的限流算法有滑动窗口，令牌桶算法和漏桶算法，或 者直接使用队列、加锁等，在layering-cache里面可以使用分布式锁来做限流 

3、布隆过滤器

预先将所有缓存数据的key存放到布隆过滤器中，当一个查询请求过来的时候，先判断这个key在布隆过滤器中是否存在？

如果不存在，直接返回提示，都不用去查缓存更不用说DB了；

如果存在，则去查缓存，但我们知道布隆过滤器判断存在有一定的误判率，这里我是这样理解的，如果这个误判率针对你们的业务场景是可被接受的则可以忽略，另外我们在用Guava实现布隆过滤器的时候可以指定误判率不超过多少，你可以指定一个可被你接受的值。再或者，因为布隆过滤器可以过滤掉绝大多数的恶意key，针对少部分的漏网之鱼，我们可以在缓存层面使用功能上面说过的缓存空值或加锁的方案。

## 二、缓存击穿

**缓存击穿和缓存穿透不一样**

缓存击穿是指某个热点key在失效的瞬间（一般是缓存时间到期），持续的大并发请求穿破缓存，直接打到数据库，就像在一个屏障上凿开了一个洞，造成数据库压力瞬间增大，这就是缓存击穿。

热点key，某个访问非常频繁，访问量非常大的一个缓存key，我们叫做热点key。

**缓存击穿的解决方案**

1、设置热点key永不过期

 2、加锁，根据热点key从缓存中获取到的value为空时，先锁上，再去查DB将数据加载到缓存，若其它线程获取锁失败，则等待一段时间后重试，从而避免了大量请求直接打到DB。单机可以使用synchronized或ReentrantLock，分布式需要加分布式锁，如Redis分布式锁。【为了不阻塞对其他key的请求，此处可以用热点key来加锁】

## 三、缓存雪崩

在高并发下，大量的缓存key在同一时间失效，导致大量的请求落到数据库上，如活动系统里面同时进行着非常多的活动，但是在某个时间点所有的活动缓存全部过期。如redis直接宕机。

**缓存雪崩的解决方案**

1、保证缓存层服务高可用性，如使用Redis Sentinel 和 Redis Cluster，双机房部署，保证Redis服务高可用。

2、通过设置不同的过期时间（随机数），来错开缓存过期，从而避免缓存集中失效。

